#include "stdafx.h"
#include "CXeKeyVault.h"
#include "XeCrypt.h"
#include "util.h"
#ifndef _XBOX
#include <wincrypt.h>
#endif
int CXeKeyVault::CalculateNonce(BYTE* pbNonceBuff, DWORD cbNonceBuff)
{
	WORD kvVer = bswap16(*this->pwKeyVaultVersion);
	XeCryptHmacSha(this->pbCPUKey, 0x10, ((BYTE*)&this->xeData) + 0x10, 0x3ff0, (BYTE*)&kvVer, 0x2, 0, 0, pbNonceBuff, cbNonceBuff);
	return 1;
}
int CXeKeyVault::RandomizeKeys()
{
	BYTE random[0x1000];
	BYTE randomKey[0x6];
	CHAR randomSerial[0x18];
	XeRsaKey rsaPub;
    XeRsaKey rsaPrv;
	Log(1, "randomizing KeyVault keys...\n");
	// get some random data to work with
	XeCryptRandom((BYTE*)&randomKey, 0x6);
	XeCryptRc4((BYTE*)&randomKey, 0x6, (BYTE*)&random, 0x1000);

	// randomize serial numbers
	_snprintf_s((CHAR*)&randomSerial, 0x18, 0x18, "%013I64u", *(ULONGLONG*)&random);
	randomSerial[0xC] = 0;
	randomSerial[0xD] = 0;
	randomSerial[0xE] = 0;
	randomSerial[0xF] = 0;
	
	// set console/mobo serial numbers
	memcpy(&this->xeData.sz14ConsoleSerialNumber, &randomSerial, 0xC);
	memcpy(&this->xeData.b15MoboSerialNumber, (BYTE*)&random + 0x20, 0x8);

	// set region to devkit
	this->xeData.w16GameRegion = bswap16(0x7FFF);

	// randomize some keys
	memcpy(&this->xeData.b12ReservedRandomKey1, (BYTE*)&random + 0x30, 0x10);
	memcpy(&this->xeData.b13ReservedRandomKey2, (BYTE*)&random + 0x40, 0x10);
	memcpy(&this->xeData.b17ConsoleObfuscationKey, (BYTE*)&random + 0x50, 0x10);
	memcpy(&this->xeData.b18KeyObfuscationKey, (BYTE*)&random + 0x60, 0x10);
	memcpy(&this->xeData.b1ADvdKey, (BYTE*)&random + 0x70, 0x10);
	memcpy(&this->xeData.b1BPrimaryActivationKey, (BYTE*)&random + 0x80, 0x18);
	memcpy(&this->xeData.b1CSecondaryActivationKey, (BYTE*)&random + 0x98, 0x10);

#ifndef _DEBUG
	Log(1, "KeyVault keys randomized\n");
	return 0;
#else
	// if we're a debug build lets remake the certificate
	// REMOVE THIS PART OF THE CODE IF YOUR GIVING IT OUT
	Log(1, "randomizing KeyVault certificate...");
	BYTE tempMasterKey[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

#ifdef _XBOX
	bool keysgenned = XeCryptBnQwNeRsaKeyGen(0x400, 0x10001, &rsaPub, &rsaPrv);
	if(!keysgenned)
	{
		Log(1, "error generating console private key, returning...\n");
		return 1;
	}
#else
	HCRYPTPROV hCryptProv = NULL;
	LPCSTR UserName = "RGBuild++Container";

	if(CryptAcquireContext(
	   &hCryptProv,               // Handle to the CSP.
	   UserName,                  // Container name.
	   NULL,                      // Use the default provider.
	   PROV_RSA_FULL,             // Provider type.
	   0))                        // Flag values.
	{
		Log(0, "A crypto context with the %s key container \n", UserName);
		Log(0, "has been acquired.\n\n");
	}
	else
	{
		if (GetLastError() == NTE_BAD_KEYSET)
		{
		   if(CryptAcquireContext(
			  &hCryptProv, 
			  UserName, 
			  NULL, 
			  PROV_RSA_FULL, 
			  CRYPT_NEWKEYSET)) 
			{
				Log(0, "A new key container has been created.\n");
			}
			else
			{
				Log(1, "Could not create a new key container.\n");
				return 1;
			}
		}
		else
		{
			Log(1, "A cryptographic service handle could not be acquired.\n");
			return 1;
		}
	}
	HCRYPTKEY key;
	bool keygenned = CryptGenKey(hCryptProv, CALG_RSA_SIGN, (0x400 << 16) | CRYPT_EXPORTABLE, &key);
	DWORD len = 0;
	DWORD len2 = 0;
	CryptExportKey(key, NULL, PRIVATEKEYBLOB, 0, NULL, &len);
	BYTE* privkey = (BYTE*)malloc(len);
	CryptExportKey(key, NULL, PRIVATEKEYBLOB, 0, privkey, &len);
	
	memcpy(((BYTE*)&rsaPrv) + 0x10, &privkey[0x14], 0x1C0);
	rsaPrv.exponent = bswap32(0x10001);
	rsaPrv.modulusSize = bswap32(0x10);
	// now byteswap the rest of that shit
	for(int i = 0; i < (0x1C0 / 8); i++)
	{
		BYTE* cur = (BYTE*)(&rsaPrv) + 0x10 + (i*8);
		ULONGLONG* lo = (ULONGLONG*)cur;
		*lo = bswap64(*lo);
	}
	memcpy((void*)&rsaPub, (void*)&rsaPrv, 0x90);

	if (CryptReleaseContext(hCryptProv,0))
	{
	  Log(0, "key generated, handle freed.\n");
	}
	else
	{
	  Log(1, "The handle could not be freed!\n");
	}
#endif


	// copy the new private key
	memcpy(&this->xeData.b33ConsolePrivateKey, (BYTE*)&rsaPrv, 0x1D0);

	// remake the cert
	this->xeData.b36ConsoleCertificate.CertSize = bswap16(0x1a8);

	// make the console id
	while(true)
	{
		memcpy(&this->xeData.b36ConsoleCertificate.ConsoleId, (BYTE*)&random + 0x100, 0x5);
		this->xeData.b36ConsoleCertificate.ConsoleId[0] = (this->xeData.b36ConsoleCertificate.ConsoleId[0] % 9) + 1;
		this->xeData.b36ConsoleCertificate.ConsoleId[1] = 0x56;
		this->xeData.b36ConsoleCertificate.ConsoleId[2] = 0x73;
		this->xeData.b36ConsoleCertificate.ConsoleId[3] = 0xC3;

		ULONGLONG idtest = 0;
		for(int i = 0; i < 5; i++)
		{
			idtest = idtest << 8;
			idtest = idtest + this->xeData.b36ConsoleCertificate.ConsoleId[i];
		}
		idtest = idtest >> 4;
		int div = 0xA;
		ULONGLONG r10 = 0;

		// not sure what this does but the recovery does it
		// seems to be some kind of algo for the consoleid
		// XeKeysGetConsoleID panics if last byte of consoleid has bit 1 or 2 set
		// think this stops it from being set somehow
		// maybe last byte is a check byte?
		while(true)
		{
			if(idtest != 0)
			{

				ULONGLONG tmp = idtest / div;
				tmp = tmp * 0xA;
				tmp = idtest - tmp;
				idtest = idtest / div;
				r10 = tmp + r10;
			}
			else
			{
				idtest = r10 / div;
				div = this->xeData.b36ConsoleCertificate.ConsoleId[4];
				idtest = idtest * 0xA;
				idtest = r10 - idtest;
				r10 = div & 0xFFFFFFF0;
				idtest = r10 | idtest;
				this->xeData.b36ConsoleCertificate.ConsoleId[4] = (BYTE)(idtest & 0xFF);
				break;
			}
		}

		if((this->xeData.b36ConsoleCertificate.ConsoleId[4] & 0xF) <= 9)
			break;
		// if last byte & 0xF is higher than 9 lets try making another consoleid
		// cuz noone likes kernel panics amirite
	}

	// set the part number
	CHAR randomPartNo[0x18];
	_snprintf_s((CHAR*)&randomPartNo, 0x18, 0x18, "%013I64u", *(ULONGLONG*)&random + 0x10);
	//strcpy((CHAR*)&randomPartNo, "cheatisafag");
	memcpy(&this->xeData.b36ConsoleCertificate.ConsolePartNumber, &randomPartNo, 0xB);
	


	// these fields should probably be set to 0
	//*(DWORD*)&this->xeData.b36ConsoleCertificate.Reserved = 0x35343633;
	//this->xeData.b36ConsoleCertificate.Privileges = 0x3139;
	*(DWORD*)&this->xeData.b36ConsoleCertificate.Reserved = 0;
	this->xeData.b36ConsoleCertificate.Privileges = 0xFFFF;

	// set this to testkit
	this->xeData.b36ConsoleCertificate.ConsoleType = bswap32(0x40000001);

	// randomize mfg date
	BYTE date[2];
	XeCryptRandom((u8*)&date, 2);
	date[0] = date[0] % 13;
	date[1] = date[1] % 29;
	if(date[0] == 0) date[0]++;
	if(date[1] == 0) date[0]++;

	// seems thefallen's kvs does this
	date[0] = this->xeData.b36ConsoleCertificate.ConsoleId[0];

	CHAR buff[9];
	sprintf_s((CHAR*)&buff, 9, "%02d-%02d-07", date[0], date[1]);
	memcpy(&this->xeData.b36ConsoleCertificate.ManufacturingDate, (BYTE*)&buff, 8);

	// copy the public key in
	this->xeData.b36ConsoleCertificate.ConsolePublicKey.PublicExponent = bswap32(0x10001);
	memcpy((BYTE*)&this->xeData.b36ConsoleCertificate.ConsolePublicKey.Modulus, (BYTE*)&rsaPub.modulus, 0x80);
	
	// sign the certificate
	BYTE certDigest[0x14];
	BYTE certSignature[0x100];
	XeCryptSha((BYTE*)&this->xeData.b36ConsoleCertificate, 0xA8, 0, 0, 0, 0, certDigest, 0x14);
	XeCryptBnDwLePkcs1Format((BYTE*)&certDigest, 0, certSignature, 0x100);
	XeCryptBnQw_SwapDwQwLeBe((u64*)&certSignature, (u64*)&this->xeData.b36ConsoleCertificate.Signature, 0x20);
	XeCryptBnQwNeRsaPrvCrypt((u64*)&this->xeData.b36ConsoleCertificate.Signature, (u64*)&certSignature, (XeRsaKey*)&tempMasterKey);
	XeCryptBnQw_SwapDwQwLeBe((u64*)&certSignature, (u64*)&this->xeData.b36ConsoleCertificate.Signature, 0x20);

	// now fix the des keys and we're done
	return this->RepairDesKeys();
#endif
}
KV_CONTROLLER_DATA DesData[] = {
	// k1idx, k2idx, k1data, k2data
	{ 0x1D, 0x1E, 
// think these keys are used on beta kits only, recovery still uses em tho
// probably makes the other keys here for beta only too, meh
		{0xC2, 0x15, 0xE5, 0x5E, 0xE5, 0x51, 0x94, 0x2A, 0xEC, 0x3D, 0x45, 0xEC, 0xB6, 0xE6, 0xF2, 0x16}, 
		{0xC7, 0x45, 0xAD, 0x1F, 0x08, 0x0B, 0xD9, 0xE9, 0x9B, 0x1C, 0x34, 0xE3, 0xA4, 0x6D, 0xC8, 0xC4}
	// for comparison, here are retail/devkit keys
	//	{0xE3, 0x5B, 0xFB, 0x1C, 0xCD, 0xAD, 0x32, 0x5B, 0xF7, 0x0E, 0x07, 0xFD, 0x62, 0x3D, 0xA7, 0xC4},
	//	{0x8F, 0x29, 0x08, 0x38, 0x0B, 0x5B, 0xFE, 0x68, 0x7C, 0x26, 0x46, 0x2A, 0x51, 0xF2, 0xBC, 0x19}
	},
	{ 0x1F, 0x20, 
		{0x68, 0xDA, 0xB6, 0x2F, 0x49, 0xC2, 0xF2, 0xB3, 0x1C, 0xF7, 0x16, 0x2F, 0xBC, 0x19, 0x02, 0xA2}, 
		{0x98, 0x40, 0xF7, 0x58, 0x5E, 0x20, 0xF2, 0x2A, 0x13, 0x0B, 0xAD, 0x68, 0x61, 0x13, 0x1A, 0x1A}
	},
	{ 0x21, 0x22, 
		{0xFD, 0xEF, 0x08, 0x4C, 0x68, 0x2C, 0x76, 0x0D, 0x91, 0x49, 0x13, 0x0E, 0x4C, 0x5B, 0xBF, 0x38},
		{0xEF, 0x37, 0xF2, 0xE6, 0x54, 0xEA, 0x0D, 0x5E, 0xEA, 0xE3, 0x97, 0x7C, 0x61, 0x3B, 0x3B, 0x6E}
	},
	{ 0x23, 0x24, 
		{0xB9, 0xE0, 0x9E, 0x68, 0x04, 0x83, 0x91, 0xB3, 0x32, 0x45, 0x7A, 0xDA, 0x43, 0x6B, 0x80, 0xAD},
		{0x92, 0x5D, 0x29, 0x6E, 0xB0, 0x61, 0x0B, 0xF1, 0xD6, 0x29, 0x3B, 0xC8, 0xC7, 0xD9, 0x32, 0xBC}
	},
	{ 0x25, 0x26, 
		{0x97, 0x57, 0x8A, 0x01, 0xD9, 0x76, 0x01, 0x04, 0x23, 0xFE, 0xC7, 0xDC, 0x10, 0x8F, 0x58, 0xDC},
		{0xAE, 0x79, 0xE3, 0x8F, 0x8C, 0x19, 0x64, 0x10, 0xA4, 0xC1, 0x7A, 0xEC, 0x0E, 0x73, 0xBC, 0x5D}
	},
	{ 0x27, 0x28, 
		{0x97, 0x57, 0x8A, 0x01, 0xD9, 0x76, 0x01, 0x04, 0x23, 0xFE, 0xC7, 0xDC, 0x10, 0x8F, 0x58, 0xDC},
		{0xAE, 0x79, 0xE3, 0x8F, 0x8C, 0x19, 0x64, 0x10, 0xA4, 0xC1, 0x7A, 0xEC, 0x0E, 0x73, 0xBC, 0x5D}
	},
	{ 0x29, 0x2A, 
		{0x68, 0xDA, 0xB6, 0x2F, 0x49, 0xC2, 0xF2, 0xB3, 0x1C, 0xF7, 0x16, 0x2F, 0xBC, 0x19, 0x02, 0xA2},
		{0x98, 0x40, 0xF7, 0x58, 0x5E, 0x20, 0xF2, 0x2A, 0x13, 0x0B, 0xAD, 0x68, 0x61, 0x13, 0x1A, 0x1A}
	},
	{ 0x2B, 0x2C, 
		{0xFD, 0xEF, 0x08, 0x4C, 0x68, 0x2C, 0x76, 0x0D, 0x91, 0x49, 0x13, 0x0E, 0x4C, 0x5B, 0xBF, 0x38},
		{0xEF, 0x37, 0xF2, 0xE6, 0x54, 0xEA, 0x0D, 0x5E, 0xEA, 0xE3, 0x97, 0x7C, 0x61, 0x3B, 0x3B, 0x6E}
	},
	{ 0x2D, 0x2E, 
		{0x0B, 0xC1, 0x49, 0xF1, 0xE9, 0x38, 0x5D, 0x80, 0xBA, 0xEF, 0x98, 0x83, 0x7A, 0xD3, 0x32, 0xD0},
		{0x70, 0x5D, 0xBF, 0x3E, 0xF1, 0x86, 0x3D, 0xDA, 0x86, 0x2C, 0x1C, 0xDA, 0x89, 0x08, 0xA1, 0xD9}
	},
	{ 0x2F, 0x30, 
		{0x97, 0x57, 0x8A, 0x01, 0xD9, 0x76, 0x01, 0x04, 0x23, 0xFE, 0xC7, 0xDC, 0x10, 0x8F, 0x58, 0xDC},
		{0xAE, 0x79, 0xE3, 0x8F, 0x8C, 0x19, 0x64, 0x10, 0xA4, 0xC1, 0x7A, 0xEC, 0x0E, 0x73, 0xBC, 0x5D}
	},
	{ 0x31, 0x22, 
		{0x97, 0x57, 0x8A, 0x01, 0xD9, 0x76, 0x01, 0x04, 0x23, 0xFE, 0xC7, 0xDC, 0x10, 0x8F, 0x58, 0xDC},
		{0xAE, 0x79, 0xE3, 0x8F, 0x8C, 0x19, 0x64, 0x10, 0xA4, 0xC1, 0x7A, 0xEC, 0x0E, 0x73, 0xBC, 0x5D}
	}
};
int CXeKeyVault::RepairDesKeys()
{
	BYTE desSalt[0x8];
	BYTE desInput[0x14];
	Log(1, "repairing KeyVault DES keys...\n");
	memcpy(&desSalt, &this->xeData.b36ConsoleCertificate.ConsoleId, 0x5);
	desSalt[5] = 0x80;
	desSalt[6] = 0x81;
	desSalt[7] = 0x82;
	XeCryptSha((BYTE*)&desSalt, 8, 0, 0, 0, 0, (BYTE*)&desInput, 0x14);
	BYTE* keyPoint = (BYTE*)&this->xeData.b1DGlobalDevice2DesKey1;
	for(int i = 0; i < 0xB; i++)
	{
		if(i == 0)
		{
			memcpy(keyPoint, &DesData[i].dwKey1Data, 0x10);
			memcpy(keyPoint + 0x10, &DesData[i].dwKey2Data, 0x10);
		}
		else
		{
			BYTE desPar[0x18];
			BYTE desKey[0x18];
			BYTE desOut[0x10];
			BYTE desOut2[0x10];
			XeDes3Context state;
			ULONGLONG feed = 0;
			memcpy(&desPar, DesData[i].dwKey1Data, 0x10);
			XeCryptDesParity((BYTE*)&desPar, 0x18, (BYTE*)&desKey);
			XeCryptDes3Key(&state, (BYTE*)&desKey);
			XeCryptDes3Cbc(&state, (BYTE*)&desInput, 0x10, (BYTE*)&desOut, (BYTE*)&feed, XE_CRYPT_ENC);
			feed = 0;
			memcpy(&desPar, DesData[i].dwKey2Data, 0x10);
			XeCryptDesParity((BYTE*)&desPar, 0x18, (BYTE*)&desKey);
			XeCryptDes3Key(&state, (BYTE*)&desKey);
			XeCryptDes3Cbc(&state, (BYTE*)&desInput + 4, 0x10, (BYTE*)&desOut2, (BYTE*)&feed, XE_CRYPT_ENC);
			feed = 0;

			memcpy(keyPoint, &desOut, 0x10);
			memcpy(keyPoint + 0x10, &desOut2, 0x10);
		}
		keyPoint += 0x20;
	}
	return 0;
}
int CXeKeyVault::Crypt(bool isDecrypting)
{
	BYTE* data = ((BYTE*)&xeData) + 0x10;
	Log(1, "crypting KeyVault...\n");
	//crypt the bitch :D:DD
	byte nonce[0x10];
	byte calcnonce[0x10];
	if(!isDecrypting)
	{
		this->CalculateNonce((BYTE*)&this->xeData.bKeyVaultNonce, 0x10);
	}
	memcpy((void*)&nonce, (void*)this->pbHmacShaNonce, 0x10);
	XeCryptHmacSha(this->pbCPUKey, 0x10, this->pbHmacShaNonce, 0x10, 0, 0, 0, 0, this->bRc4Key, 0x10);
	XeRc4Context state;
	XeCryptRc4Key(&state, this->bRc4Key, 0x10);
	XeCryptRc4Ecb(&state, data, 0x4000 - 0x10);
	this->CalculateNonce((BYTE*)&calcnonce, 0x10);
	this->bIsDecrypted = false;
	if(!isDecrypting)
		return 0;
	this->bIsDecrypted = true;
	if(!memcmp(&nonce, &calcnonce, 0x10))
		return 0;
	else return 1;
}
int CXeKeyVault::Save(bool saveEncrypted)
{
	this->pbHmacShaNonce = (BYTE*)&xeData.bKeyVaultNonce;
	BYTE* data = ((BYTE*)&xeData) + 0x10;
	if(this->bIsDecrypted)
	{
#ifndef _XBOX
		// byteswap stuff
		this->xeData.w4OddFeatures = bswap16(this->xeData.w4OddFeatures);
		this->xeData.w5OddAuthType = bswap16(this->xeData.w5OddAuthType);
		this->xeData.w16GameRegion = bswap16(this->xeData.w16GameRegion);
		this->xeData.dw6RestrictedHvExtLoader = bswap32(this->xeData.dw6RestrictedHvExtLoader);
		this->xeData.dw7PolicyFlashSize = bswap32(this->xeData.dw7PolicyFlashSize);
		this->xeData.dw8PolicyBuiltInUsbMuSize = bswap32(this->xeData.dw8PolicyBuiltInUsbMuSize);
		this->xeData.dw9ReservedDword4 = bswap32(this->xeData.dw9ReservedDword4);
		this->xeData.qwARestrictedPrivileges = bswap64(this->xeData.qwARestrictedPrivileges);
		this->xeData.qwBReservedQword2 = bswap64(this->xeData.qwBReservedQword2);
		this->xeData.qwCReservedQword3 = bswap64(this->xeData.qwCReservedQword3);
		this->xeData.qwDReservedQword4 = bswap64(this->xeData.qwDReservedQword4);
		this->xeData.b36ConsoleCertificate.CertSize = bswap16(this->xeData.b36ConsoleCertificate.CertSize);
		this->xeData.b36ConsoleCertificate.ConsoleType = bswap32(this->xeData.b36ConsoleCertificate.ConsoleType);
		this->xeData.b36ConsoleCertificate.Privileges = bswap16(this->xeData.b36ConsoleCertificate.Privileges);
#endif
		if(saveEncrypted)
			this->Crypt(false);
	}
	Log(0, "saved KeyVault\n");
	return 0;
}
int CXeKeyVault::Load(bool isEncrypted)
{
	this->pbHmacShaNonce = (BYTE*)&xeData.bKeyVaultNonce;
	BYTE* data = ((BYTE*)&xeData) + 0x10;
	if(!isEncrypted)
	{
		this->bIsDecrypted = TRUE;
#ifndef _XBOX
		// byteswap stuff
		this->xeData.w4OddFeatures = bswap16(this->xeData.w4OddFeatures);
		this->xeData.w5OddAuthType = bswap16(this->xeData.w5OddAuthType);
		this->xeData.w16GameRegion = bswap16(this->xeData.w16GameRegion);
		this->xeData.dw6RestrictedHvExtLoader = bswap32(this->xeData.dw6RestrictedHvExtLoader);
		this->xeData.dw7PolicyFlashSize = bswap32(this->xeData.dw7PolicyFlashSize);
		this->xeData.dw8PolicyBuiltInUsbMuSize = bswap32(this->xeData.dw8PolicyBuiltInUsbMuSize);
		this->xeData.dw9ReservedDword4 = bswap32(this->xeData.dw9ReservedDword4);
		this->xeData.qwARestrictedPrivileges = bswap64(this->xeData.qwARestrictedPrivileges);
		this->xeData.qwBReservedQword2 = bswap64(this->xeData.qwBReservedQword2);
		this->xeData.qwCReservedQword3 = bswap64(this->xeData.qwCReservedQword3);
		this->xeData.qwDReservedQword4 = bswap64(this->xeData.qwDReservedQword4);
		this->xeData.b36ConsoleCertificate.CertSize = bswap16(this->xeData.b36ConsoleCertificate.CertSize);
		this->xeData.b36ConsoleCertificate.ConsoleType = bswap32(this->xeData.b36ConsoleCertificate.ConsoleType);
		this->xeData.b36ConsoleCertificate.Privileges = bswap16(this->xeData.b36ConsoleCertificate.Privileges);
#endif
	}
	else
	{
		int res = this->Crypt(true);
		if(res == 0)
			return this->Load(false);
		else
			return 1;
	}
	Log(1, "loaded KeyVault\n");
	return 0;
}