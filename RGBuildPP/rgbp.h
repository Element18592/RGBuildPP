// RGBuildPP private header file

// NEVER use the main functions in code!
// if you need to use randomizeKeysContinue, call rkc
// or for resign4BL call rbl instead
// TODO: fix windows keyvault private key generation

#ifndef RGBPH
#define RGBPH
inline BOOL randomizeKeysContinue(CXeKeyVault* kv)
{
	XeRsaKey rsaPub;
    XeRsaKey rsaPrv;
	BYTE tempMasterKey[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
	
	BYTE randomKey[0x6];
	BYTE random[0x1000];

	// get some random data to work with
	XeCryptRandom((BYTE*)&randomKey, 0x6);
	XeCryptRc4((BYTE*)&randomKey, 0x6, (BYTE*)&random, 0x1000);

	Log(1, "randomizeKeysContinue: randomizing KeyVault certificate...");
#ifdef _XBOX
	BOOL keysgenned = XeCryptBnQwNeRsaKeyGen(0x400, 0x10001, &rsaPub, &rsaPrv);
	if(!keysgenned)
	{
		Log(1, "randomizeKeysContinue: error generating console private key, returning...\n");
		return 1;
	}
#else
	// TODO: make sure this works
	HCRYPTPROV hCryptProv = NULL;
	LPCSTR UserName = "RGBuildPPContainer";

	if(CryptAcquireContext(
	   &hCryptProv,               // Handle to the CSP.
	   UserName,                  // Container name.
	   NULL,                      // Use the default provider.
	   PROV_RSA_FULL,             // Provider type.
	   0))                        // Flag values.
	{
		Log(0, "A crypto context with the %s key container \n", UserName);
		Log(0, "has been acquired.\n\n");
	}
	else
	{
		if (GetLastError() == NTE_BAD_KEYSET)
		{
		   if(CryptAcquireContext(
			  &hCryptProv, 
			  UserName, 
			  NULL, 
			  PROV_RSA_FULL, 
			  CRYPT_NEWKEYSET)) 
			{
				Log(0, "A new key container has been created.\n");
			}
			else
			{
				Log(1, "Could not create a new key container.\n");
				return 1;
			}
		}
		else
		{
			Log(1, "A cryptographic service handle could not be acquired.\n");
			return 1;
		}
	}
	HCRYPTKEY key;
	BOOL keygenned = CryptGenKey(hCryptProv, CALG_RSA_SIGN, (0x400 << 16) | CRYPT_EXPORTABLE, &key);
	DWORD len = 0;
	DWORD len2 = 0;
	CryptExportKey(key, NULL, PRIVATEKEYBLOB, 0, NULL, &len);
	BYTE* privkey = (BYTE*)malloc(len);
	CryptExportKey(key, NULL, PRIVATEKEYBLOB, 0, privkey, &len);
	
	memcpy(((BYTE*)&rsaPrv) + 0x10, &privkey[0x14], 0x1C0);
	rsaPrv.exponent = bswap32(0x10001);
	rsaPrv.modulusSize = bswap32(0x10);
	// now byteswap the rest of that shit
	for(int i = 0; i < (0x1C0 / 8); i++)
	{
		BYTE* cur = (BYTE*)(&rsaPrv) + 0x10 + (i*8);
		ULONGLONG* lo = (ULONGLONG*)cur;
		*lo = bswap64(*lo);
	}
	memcpy((void*)&rsaPub, (void*)&rsaPrv, 0x90);

	if (CryptReleaseContext(hCryptProv,0))
	{
	  Log(0, "key generated, handle freed.\n");
	}
	else
	{
	  Log(1, "The handle could not be freed!\n");
	}
#endif


	// copy the new private key
	memcpy(&kv->xeData.b33ConsolePrivateKey, (BYTE*)&rsaPrv, 0x1D0);

	// remake the cert
	kv->xeData.b36ConsoleCertificate.CertSize = bswap16(0x1a8);

	// make the console id
	while(true)
	{
		memcpy(&kv->xeData.b36ConsoleCertificate.ConsoleId, (BYTE*)&random + 0x100, 0x5);
		kv->xeData.b36ConsoleCertificate.ConsoleId[0] = (kv->xeData.b36ConsoleCertificate.ConsoleId[0] % 9) + 1;
		kv->xeData.b36ConsoleCertificate.ConsoleId[1] = 0x56;
		kv->xeData.b36ConsoleCertificate.ConsoleId[2] = 0x73;
		kv->xeData.b36ConsoleCertificate.ConsoleId[3] = 0xC3;

		ULONGLONG idtest = 0;
		for(int i = 0; i < 5; i++)
		{
			idtest = idtest << 8;
			idtest = idtest + kv->xeData.b36ConsoleCertificate.ConsoleId[i];
		}
		idtest = idtest >> 4;
		int div = 0xA;
		ULONGLONG r10 = 0;

		// not sure what this does but the recovery does it
		// seems to be some kind of algo for the consoleid
		// XeKeysGetConsoleID panics if last byte of consoleid has bit 1 or 2 set
		// think this stops it from being set somehow
		// maybe last byte is a check byte
		while(true)
		{
			if(idtest != 0)
			{

				ULONGLONG tmp = idtest / div;
				tmp = tmp * 0xA;
				tmp = idtest - tmp;
				idtest = idtest / div;
				r10 = tmp + r10;
			}
			else
			{
				idtest = r10 / div;
				div = kv->xeData.b36ConsoleCertificate.ConsoleId[4];
				idtest = idtest * 0xA;
				idtest = r10 - idtest;
				r10 = div & 0xFFFFFFF0;
				idtest = r10 | idtest;
				kv->xeData.b36ConsoleCertificate.ConsoleId[4] = (BYTE)(idtest & 0xFF);
				break;
			}
		}

		if((kv->xeData.b36ConsoleCertificate.ConsoleId[4] & 0xF) <= 9)
			break;
		// if last byte & 0xF is higher than 9 lets try making another consoleid
		// cuz nobody likes kernel panics
	}

	// set the part number
	CHAR randomPartNo[0x18];
	_snprintf_s(randomPartNo, 0x18, 0x18, "%013I64u", *(ULONGLONG*)&random + 0x10);
	memcpy(&kv->xeData.b36ConsoleCertificate.ConsolePartNumber, &randomPartNo, 0xB);

	// these fields should probably be set to 0
	*(DWORD*)&kv->xeData.b36ConsoleCertificate.Reserved = 0;
	kv->xeData.b36ConsoleCertificate.Privileges = 0xFFFF;

	// set this to testkit
	kv->xeData.b36ConsoleCertificate.ConsoleType = bswap32(0x40000001);

	// randomize mfg date
	BYTE date[2];
	XeCryptRandom((u8*)&date, 2);
	date[0] = date[0] % 13;
	date[1] = date[1] % 29;
	if(date[0] == 0) date[0]++;
	if(date[1] == 0) date[0]++;

	// seems thefallen's kvs do this
	date[0] = kv->xeData.b36ConsoleCertificate.ConsoleId[0];

	CHAR buff[9];
	sprintf_s(buff, 9, "%02d-%02d-07", date[0], date[1]);
	memcpy(&kv->xeData.b36ConsoleCertificate.ManufacturingDate, (BYTE*)&buff, 8);

	// copy the public key in
	kv->xeData.b36ConsoleCertificate.ConsolePublicKey.PublicExponent = bswap32(0x10001);
	memcpy(kv->xeData.b36ConsoleCertificate.ConsolePublicKey.Modulus, (BYTE*)&rsaPub.modulus, 0x80);
	
	// sign the certificate
	BYTE certDigest[0x14];
	BYTE certSignature[0x100];
	XeCryptSha((BYTE*)&kv->xeData.b36ConsoleCertificate, 0xA8, 0, 0, 0, 0, certDigest, 0x14);
	XeCryptBnDwLePkcs1Format((BYTE*)&certDigest, 0, certSignature, 0x100);
	XeCryptBnQw_SwapDwQwLeBe((u64*)&certSignature, (u64*)&kv->xeData.b36ConsoleCertificate.Signature, 0x20);
	XeCryptBnQwNeRsaPrvCrypt((u64*)&kv->xeData.b36ConsoleCertificate.Signature, (u64*)&certSignature, (XeRsaKey*)&tempMasterKey);
	XeCryptBnQw_SwapDwQwLeBe((u64*)&certSignature, (u64*)&kv->xeData.b36ConsoleCertificate.Signature, 0x20);

	// now fix the des keys and we're done
	return kv->RepairDesKeys();
}
inline BOOL resign4BL(CXeBootloader4BL* bl)
{
	if((bl->blHdr.wMagic & 0x1000) != 0x1000)
		return TRUE; // we can't sign retail bootloaders :(

	u64 qwkey[] = {
	0x0000002000010001, //cqw (pub found in SB)//dwPubExp
	0x0000000000000000, //qwReserved
	//aqwM
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
	//aqwP
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
	//aqwQ
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
	//aqwDP
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 
	//aqwDQ
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 
	//aqwCR
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
	0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 
	};
    char salt[] = "XBOX_ROM_4";
	Log(1, "resign4BL: generating RotSumSha hash...\n");

	BYTE digest[0x14];
	XeCryptRotSumSha(bl->pbData, 0x10, (bl->pbData + 0x120), bl->blHdr.dwLength - 0x120, digest, 0x14);
	XeRsaKey signKey;
	XeCryptBnQw_SwapLeBe((u64*)qwkey, (u64*)&signKey, sizeof(qwkey) / sizeof(u64));
#ifdef _XBOX
	XeCryptBnQw_SwapLeBe((u64*)&signKey, (u64*)&signKey, sizeof(qwkey) / sizeof(u64));
#endif
	Log(1, "resign4BL: creating loader signature...\n");
	u64 tempSig[0x20];
	if(!XeCryptBnQwBeSigCreate(tempSig, digest, (BYTE*)salt, (XeRsaKey*)&signKey))
		return false;
	return XeCryptBnQwNeRsaPrvCrypt(tempSig, (u64*)&bl->pbData[0x20], (XeRsaKey*)&signKey);
}

// aliases to use in main code
inline BOOL rkc(CXeKeyVault* kv)
{
	return randomizeKeysContinue(kv);
}
inline BOOL rbl(CXeBootloader4BL* bl)
{
	return resign4BL(bl);
}

#endif